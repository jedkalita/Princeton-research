import math
import numpy as np
from scipy.stats import rv_discrete
import threading
import time
import logging
import random
import matplotlib.pyplot as plt

logging.basicConfig(level=logging.DEBUG,
                    format='(%(threadName)-9s) %(message)s', )

class Environment: #the class that will be simulating the adversary in terms of generating rewards back and forth with
    #each player
    def __init__(self, numPlayers, N, profit_scenarios):
        self.numPlayers = numPlayers #no of players in the game
        self.N = N #no of strategies that each player has
        self.profits_decided = profit_scenarios #the cost scenarios list

    def generateRewards(self, t, strategiesPicked): #generate the cost vector for all players
    #now, we have to literally calculate all of the possible permutations between other players and their strategies
        logging.debug("About to generate rewards for time : %d" %t)
        for j in range(len(strategiesPicked)):
            logging.debug("Player %d executed strategy %d" % (j, strategiesPicked[j]))
        totalScenarios = (self.numPlayers - 1) * self.N #the different scenarios of strategies per remaining players that could
        #happen

        #now, decode from the strategies picked which index within the cost_scenarios to get the cost from
        sum = int(0)
        for i in range(self.numPlayers):
            sum = sum + (int(math.pow(self.N, i)) * strategiesPicked[i])
        #print("sum is : %d" % (sum))

        profits_decided = []
        for i in range(self.numPlayers):
            profits_decided.append(self.profits_decided[sum][i])
        logging.debug("Finished generating rewards for time %d" %(t))
        return profits_decided #return the cost for all players

class Player:
    def __init__(self, T, N):
        self.T = T #to make the matrix
        self.N = N #the number of actions/strategies that the player has
        self.weight = np.ones((self.N, self.T), dtype=float) #each player will have their cost vector indexed acc to the time instance
        #this has been initialized to 1.0 for all, but we really only care about for t=1 for all actions acc to the
        #algorithm
        self.weight_normalized = np.zeros((self.N, self.T), dtype=float)
        self.eta = 10 * math.sqrt(math.log(self.N) * self.N / (2 * self.T)) #the value of learning parameter between 0 and 1
        # under known T
        self.probability = np.zeros((self.N), dtype=float) #this will keep changing at each iteration, which
        #then will be used to change the weight of the picked strategy

    def pickStrategy(self, t): #this will be called for the t+1th time instance after the player has picked a strategy
        #acc to the weight matrix that existed at time t
        weighted_total = sum(self.weight[:, t])  # get the weighted sum of all strategies of the player at time t - 1
        # the above goes in the denominator

        for i in range(len(self.probability)):
            '''x = ((1 - self.eta) * (self.weight[i] / weighted_total))
            print x
            y = (self.eta / self.N)
            print y'''
            self.probability[i] = ((1 - self.eta) * (self.weight[i, t] / weighted_total)) + (self.eta / self.N)
        # get the probabilities for the individual weights to randomize over
        values_over = self.weight[:, t]  # the values over which we will pick, essentially we only need the index
        # of the strategy, hence the range() function below
        distrib = rv_discrete(values=(range(len(values_over)), self.probability))  # generate the distribution
        return (distrib.rvs(size=1))  # pick one randomized choice from the distribution created above and return, this
        # will be the strategy that the player picks, and this index will then be changed based on the cost vector fed
        # by the environment/adversary, who will keep track of the cost of each particular strategy
    def changeWeight(self, profits_decided, t, strategiesPicked, playerID): #given cost vector at time t generated by environment/adversary,
        #change the weight of the pickedStrategy at time t for time t+1
        if t == self.T - 1: #the last time step
            return #just return
        for i in range(self.N):
            if (i == strategiesPicked[playerID]):
                self.weight[strategiesPicked[playerID], t + 1] = self.weight[strategiesPicked[playerID], t] * \
                                                    math.exp(self.eta * ((profits_decided[playerID]
                                                                / self.probability[strategiesPicked[playerID]]) / self.N))
            else:
                self.weight[i, t + 1] = self.weight[i, t]


        # now normalize the weights
        sum_normalized_weight = 0
        for i in range(self.N):
            sum_normalized_weight += self.weight[i, t + 1]
        for i in range(self.N):
            self.weight_normalized[i, t + 1] = float(self.weight[i, t + 1] / sum_normalized_weight)

        print("Player ID: %d " % playerID)
        print(self.weight[:, t + 1])


'''def play(players, playerID, t): #to play each game at each time step
    probability, strategyPicked = players[playerID].pickStrategy(t) #pick the strategy
    #now, its time to change the weight of the picked strategy for the next time step by calling the environment's
    #generate rewards within, which will be operated via a lock
    players[playerID].changeWeight(strategyPicked, t, playerID, probability)'''

def play(players, playerID, strategiesPicked, players_strategies, t): #to play each game at each time step
    strategyPicked = players[playerID].pickStrategy(t) #pick the strategy
    strategiesPicked.append(strategyPicked) #for this iteration of time, per player strategy is put in a list
    #now, for the playerID append he strategy picked into the corresponding list of players_strategies
    players_strategies[playerID].append(strategyPicked) #this is to draw the plot for player strategies - not so
    #important

    #now, based upon the combination of picked strategies the same loss will be applied to each individual player

def changeWeights(players, playerID, strategiesPicked, profits_decided, t): #the function to change weights for each player
    players[playerID].changeWeight(profits_decided, t, strategiesPicked, playerID)


if __name__ == '__main__':
    Tstr = input("Enter a time horizon: ")
    T = int(Tstr)  # the total number of time divisions, T
    nof = raw_input("Enter name of file (rps_exp3/ct_exp3(.txt)) : ")  # get the file depending on the game to be played that will
    # store all of the number of players/no of strategies/cost per strategy under different scenario
    fh = open(nof, 'r')  # the file handler

    N = int(fh.readline())  # total no. of actions
    NumPl = int(fh.readline())  # no. of players
    profit_scenarios = []  # profit config for each scenario
    num_profits = int(math.pow(N, NumPl))  # the total number of different cost configurations possible
    # now, read from the input file the associated costs
    for i in range(num_profits):  # a loop to fill up the profit per strategy per player acquired from the input file
        profit = []
        line = fh.readline().split(" ")
        for k in range(len(line)):
            if (line[k] != '\n'):
                profit.append(float(line[k]))
        profit_scenarios.append(profit)

    env = Environment(NumPl, N, profit_scenarios)  # create the environment object
    # now, initialize the players in a loop
    players = []  # the list of players
    players_strategies = []  # a list of list - each element of the list will have the stretegies
    # executed by the player at that particular time step. Each element of the list pertains to one
    # individual player - this is to draw the plot player strategies
    for i in range(NumPl):  # for each player
        players.append(Player(T, N))  # each player has been initialized
        strategy_list = []  # create a new list per player
        players_strategies.append(strategy_list)  # append this empty list to correspond to the player id
        # and then this will progressively get filled up with each time step

    for i in range(T):  # at each time step, for each player, select an action and based on the scenario provided,
        # decide on the next action
        strategiesPicked = []  # a list to hold the individual strategies picked by each player
        for j in range(NumPl):
            t = threading.Thread(target=play,
                                 args=(players, j, strategiesPicked, players_strategies, i))  # first, pick a strategy
            t.start()

        # now, close all the threads
        logging.debug("Waiting for all threads after picking strategies.")
        main_thread = threading.currentThread()
        for t in threading.enumerate():
            if t is not main_thread:
                t.join()

        # now, call the environment variable to calculate the cost based on the combination
        profits_decided = env.generateRewards(i, strategiesPicked)
        # now, after all the players have  picked an individual strategy, decide on a cost for all of them
        for j in range(NumPl):
            t = threading.Thread(target=changeWeights, args=(players, j, strategiesPicked, profits_decided, i))
            t.start()

        # now join all the threads before moving on to the next time step
        logging.debug("Waiting for all threads after finishing setting weights.")
        for t in threading.enumerate():
            if t is not main_thread:
                t.join()
        print("Moving on to time step %d" % (i + 1))

    time_horizon = [t for t in range(T)]  # this will be the X-Axis for the plot - Strategy Picked vs. Time
    fig_num = 1
    for i in range(NumPl):  # for each player, create a separate plot
        fig = plt.figure()
        '''plt.figure(fig_num)
        #plt.plot(time_horizon, players_strategies[i])
        plt.scatter(time_horizon, players_strategies[i])
        fig_num = fig_num + 1'''
        # print(players_strategies[i])
        # plt.show()
        # plt.hold(False)
        # continue
        plt.suptitle('Player %d' % i)
        plt.xlabel('Time horizon')
        plt.ylabel('Weights')
        for j in range(N):
            # plt.figure(fig_num)
            plt.plot(time_horizon, players[i].weight_normalized[j], label='Weight %d' % j)
            fig_num = fig_num + 1
            plt.legend(loc='best')

    plt.show()
    # print(len(players_strategies))
    '''print(players_strategies[0])
    print(players_strategies[1])'''

    print("Game over...")
